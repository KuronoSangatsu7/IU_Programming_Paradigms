#lang slideshow
;1

;1.a
;I implemented this function previously for Assignment 1, it appends a list/element to the end of a given list
(define (my-append expr expr-2)
  (cond
    [(list? expr-2)
     (append expr expr-2)]
    [else
     (foldr cons (list expr-2) expr)]))

(define (replicate num val)
  (define (replicate-helper num-2 res)
    (cond
      [(zero? num-2)
       res]
      [else
       (replicate-helper (- num-2 1) (my-append res val))]))
  (replicate-helper num empty))

;(replicate 10 'a)
;(replicate 3 '(1 . 2))

;1.b
(define (split lis num)
  (define (split-helper num-2 res lis-2)
    (cond
      [(or
        (zero? num-2)
        (empty? lis-2))
       (cons res (list lis-2))]
      [else
       (split-helper (- num-2 1) (my-append res (first lis-2)) (rest lis-2))]))
  (split-helper num empty lis))

;(split '(1 2 3 4 5) 2)
;(split '(a b c d) 4)
;(split '(a b c) 4)
;(split '(a b c) 0)

;1.c
;Appends a list-2 to list-1 only if list-2 is non-empty
(define (append-non-empty list-1 list-2)
  (cond
    [(empty? list-2)
     list-1]
    [else
     (append list-1 list-2)]))

(define (chunks given-list chunk-size)
  (define (chunks-helper current-list current-chunk current-result)
    (cond
      [(empty? current-list)
       (append-non-empty current-result (list current-chunk))]
      [(= (length current-chunk) chunk-size)
       (chunks-helper (rest current-list) (list (first current-list)) (append current-result (list current-chunk)))]
      [else
       (chunks-helper (rest current-list) (my-append current-chunk (first current-list)) current-result)]))
  (chunks-helper given-list empty empty))

;(chunks '(1 2 3 4 5) 2)
;(chunks '(a b c d e f) 3)

;1.d
;Generates a single "window" of a given size from the beginning of a given list, to be called recursively by windows function
(define (generate-window given-list window-size)
  (define (generate-window-helper current-list current-result)
    (cond
      [(or
        (empty? current-list)
        (= (length current-result) window-size))
       current-result]
      [else
       (generate-window-helper (rest current-list) (my-append current-result (first current-list)))]))
  (generate-window-helper given-list empty))

;(generate-window '(1 2 3 4 5) 2)

(define (windows given-list window-size)
  (define (windows-helper current-list current-result)
    (cond
      [(or
        (empty? current-list)
        (< (length current-list) window-size))
       current-result]
      [else
       (windows-helper (rest current-list) (append current-result (list (generate-window current-list window-size))))]))
  (windows-helper given-list empty))

;(windows '(1 2 3 4 5) 2)
;(windows '(a b c d e) 3)

;2

;2.a
(define (pairs given-list)
  (foldl (lambda (element result)
           (cons (my-append result element) (append result (list (map (lambda (map-element) (cons element map-element)) result))))) given-list))